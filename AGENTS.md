# AGENTS.md - Chamicore AI-Assisted Development Guide

This document provides comprehensive context for AI agents (Claude, Gemini, Copilot, etc.)
working on the Chamicore project. It covers architecture, conventions, and workflows needed
to implement or modify any service.

> **This project is built entirely by AI coding agents.** Every line of code is
> generated by AI following the patterns in this document. Consistency is paramount.
>
> **Required reading order:**
> 1. This file (`AGENTS.md`) — Architecture, conventions, mandatory patterns
> 2. [`IMPLEMENTATION.md`](IMPLEMENTATION.md) — Phased task breakdown with acceptance criteria
> 3. [`templates/`](templates/) — Reference code templates (the golden patterns to copy)
> 4. The relevant [`ARCHITECTURE/ADR-*.md`](ARCHITECTURE/) for your task

---

## Project Overview

**Chamicore** is a clean-room rewrite of the [OpenCHAMI](https://github.com/OpenCHAMI)
HPC system management platform. OpenCHAMI consists of ~54 repositories of Go microservices
originally derived from Cray/HPE's CSM stack. Chamicore consolidates the essential services
into a submodule-based monorepo, simplifying development, deployment, and maintenance.

### Goals

- Consolidate the essential OpenCHAMI services into a manageable set of repositories
- Clean, idiomatic Go codebases with consistent patterns across all services
- Unified PostgreSQL backend (replacing the mix of SQLite, DuckDB, etcd, etc.)
- Simple deployment via Helm charts (production) and Docker Compose (development)
- Maintain API compatibility with OpenCHAMI where it makes sense
- AI-agent-friendly codebase with clear conventions and documentation

### Non-Goals

- 1:1 fork or port of OpenCHAMI (this is a clean-room rewrite)
- Support for legacy Cray-HPE dependencies or libraries
- Kafka/message bus (NATS JetStream for Phase 2; see [ADR-015](ARCHITECTURE/ADR-015-event-driven-architecture.md))
- Vault integration (use env vars + k8s secrets)
- Multi-database engine support (PostgreSQL only)
- Hub/spoke API gateway (per-service URL path versioning is sufficient)

---

## Repository Structure

```
chamicore/                          # Monorepo umbrella
  AGENTS.md / GEMINI.md / CLAUDE.md # AI agent instructions (symlinks)
  IMPLEMENTATION.md                 # Phased task breakdown
  Makefile                          # Cross-service task runner
  ARCHITECTURE/                     # ADR index + 15 ADRs
  templates/service/                # Golden code templates
  tests/                            # Cross-service tests (smoke/, load/)
  services/
    chamicore-{smd,bss,cloud-init,auth,discovery,ui,cli}/  # Service submodules
  shared/
    chamicore-lib/                  # Shared Go library
    chamicore-deploy/               # Helm + Compose deployment
```

---

## Services

### Service Map

| Service | Port | API Prefix | Purpose | Dependencies |
|---------|------|------------|---------|--------------|
| chamicore-smd | 27779 | `/hsm/v2/` | Central inventory and hardware state | PostgreSQL, chamicore-auth (JWKS) |
| chamicore-bss | 27778 | `/boot/v1/` | iPXE boot scripts, kernel/initrd management | PostgreSQL, SMD |
| chamicore-cloud-init | 27777 | `/cloud-init/` | Per-node cloud-init payloads | PostgreSQL, SMD |
| chamicore-kea-sync | N/A | N/A | Syncs SMD inventory to Kea DHCP | SMD API, Kea API |
| chamicore-discovery | 27776 | `/discovery/v1/` | Hardware discovery (dual-mode: service + CLI) | PostgreSQL, SMD API, chamicore-auth |
| chamicore-auth | 3333 | `/auth/v1/` | AuthN/AuthZ (OIDC, Casbin) + device creds | PostgreSQL |
| chamicore-ui | 8080 | `/` | Web management UI (Go + Vue.js BFF) | All service APIs |
| chamicore-cli | N/A | N/A | CLI client: per-service + composite workflows | All service APIs |
| chamicore-deploy | N/A | N/A | Helm charts + Docker Compose | N/A |
| chamicore-lib | N/A | N/A | Shared Go library | N/A |

> For detailed service descriptions, see:
> [ADR-011](ARCHITECTURE/ADR-011-consolidated-auth-service.md) (auth),
> [ADR-013](ARCHITECTURE/ADR-013-dedicated-discovery-service.md) (discovery),
> [ADR-014](ARCHITECTURE/ADR-014-boot-path-data-flow.md) (BSS/Cloud-Init/Kea-Sync boot path).

### Inter-Service Dependency Order

```
PostgreSQL
  -> chamicore-auth (needs DB)
    -> SMD (needs chamicore-auth for JWKS, needs DB)
      -> BSS (needs SMD + DB)
      -> Cloud-Init (needs SMD + DB)
      -> Kea-Sync (needs SMD API + Kea control agent)
      -> UI (needs all service APIs + chamicore-auth)
    -> Discovery (needs chamicore-auth for JWKS + creds, needs SMD API; NOT in boot path)
```

### Key Architecture Rules

- **Boot-path self-sufficiency** ([ADR-014](ARCHITECTURE/ADR-014-boot-path-data-flow.md)):
  BSS and Cloud-Init store data locally and serve boot requests with zero cross-service
  HTTP calls. Background sync loops poll SMD using ETags.
- **Boot endpoints are unauthenticated**: Nodes do not carry JWTs.
- **Discovery is decoupled** ([ADR-013](ARCHITECTURE/ADR-013-dedicated-discovery-service.md)):
  Dual-mode binary (server + standalone CLI). Not in the critical boot path.
- **Sync-dependent services** (BSS, Cloud-Init, Kea-Sync) must wait for initial sync
  before reporting ready (readiness handler checks `atomic.Bool` flag).

---

## Standard Service Layout

Every service repository follows this layout:

```
chamicore-<service>/
  cmd/<service>/main.go             # Entry point (minimal: wire deps, call server.Run())
  internal/
    server/                         # HTTP handlers, middleware wiring, route registration
    store/                          # Store interface + PostgresStore implementation
    model/                          # Internal domain types (separate from pkg/types/)
    config/                         # Config struct with env var loading
  pkg/
    client/                         # Typed HTTP client SDK for this service
    types/                          # Public request/response types (matches OpenAPI spec)
  api/openapi.yaml                  # OpenAPI 3.0 spec (source of truth)
  migrations/postgres/              # SQL migrations: 000001_init.up.sql / .down.sql
  Dockerfile, Makefile, go.mod, .goreleaser.yml, .gitlab-ci.yml, .golangci.yml
```

> CLI (`chamicore-cli`) and UI (`chamicore-ui`) follow different layouts. See their
> respective repositories when working on Phase 4-5.

---

## Shared Library (chamicore-lib) Packages

| Package | Purpose |
|---------|---------|
| `auth/` | JWT middleware, scope enforcement, claims extraction, JWKS fetching, dev mode bypass |
| `httputil/` | Resource envelope types, RFC 9457 error helpers, JSON response helpers, request logging, request ID, content negotiation, cache control, API versioning, secure headers, health/version/Swagger handlers |
| `httputil/client/` | Base HTTP client with retries, backoff, error parsing, token injection, request ID and trace context propagation |
| `otel/` | OTel SDK initialization, HTTP metrics/tracing middleware, DB instrumentation, Prometheus endpoint |
| `dbutil/` | PostgreSQL connection pool setup, migration runner, config struct |
| `identity/` | Component ID validation, type/state/role enums, xname compatibility helpers |
| `events/` | Event envelope types (CloudEvents-compatible), publisher/subscriber interfaces |
| `events/nats/` | NATS JetStream publisher/subscriber implementation (Phase 2) |
| `events/outbox/` | Transactional outbox pattern: PostgreSQL outbox writer, relay daemon |
| `testutil/` | Test PostgreSQL containers (testcontainers-go), HTTP test helpers |

> For the full directory layout, read the source: `shared/chamicore-lib/`.

---

## Coding Conventions

### Go Style

- **Go version**: 1.24+ (use latest stable)
- **Formatting**: `gofmt` / `goimports` (enforced by CI)
- **Linting**: `golangci-lint` with project `.golangci.yml`
- **Module path**: `git.cscs.ch/openchami/chamicore-<service>`
- **Naming**: Follow standard Go conventions. Use `MixedCaps`, not `snake_case`.
- **Package names**: Short, lowercase, single-word where possible. No `util` or `common`.
- **Exported types**: Only export what consumers need. Prefer `internal/` for service logic.

### Error Handling

- Return `error` values; do not panic except in truly unrecoverable situations.
- Wrap errors with context: `fmt.Errorf("loading config: %w", err)`.
- Use sentinel errors for well-known conditions: `var ErrNotFound = errors.New("not found")`.
- HTTP handlers map domain errors to appropriate status codes via helpers.
- Log errors at the handler level, not deep in business logic.

### Logging

- Use `rs/zerolog` exclusively. No `log`, `logrus`, `zap`, or `fmt.Println`.
- Structured logging: `log.Info().Str("component_id", id).Msg("component registered")`
- Log levels: `debug` (dev detail), `info` (operational), `warn` (recoverable),
  `error` (failures), `fatal` (only in `main()`).

### Testing

#### Unit Tests

- Use `testing` package + `stretchr/testify` for assertions.
- Table-driven tests as the default pattern.
- Test files: `*_test.go` in the same package.
- **Mock strategy**: Hand-written struct mocks with function fields. No `mockgen`/`mockery`.
  Each mock method delegates to a `Fn` field; nil fields panic (desired — catches unexpected calls):
  ```go
  type mockStore struct {
      GetComponentFn func(ctx context.Context, id string) (model.Component, error)
  }
  func (m *mockStore) GetComponent(ctx context.Context, id string) (model.Component, error) {
      return m.GetComponentFn(ctx, id)
  }
  ```
- Name test functions: `TestFunctionName_Scenario_ExpectedBehavior`.
- **100% code coverage is the target.** CI enforces this; builds fail if coverage drops.
  Run `go test -coverprofile=coverage.out ./...` and verify with `go tool cover -func=coverage.out`.
- Cover all code paths: success, error, edge cases, boundary conditions.
- Use `t.Helper()` in test helpers. Use `t.Parallel()` where safe.

#### Integration Tests

- Use `testcontainers-go` for real PostgreSQL instances in store-layer tests.
- Build tag: `//go:build integration` — run separately: `go test -tags integration ./...`
- Test the full request lifecycle including middleware (auth, logging, error handling).
- Migrations must be applied as part of integration test setup.

> For system integration tests, smoke tests, and load/performance tests, see
> [ADR-012](ARCHITECTURE/ADR-012-performance-testing-strategy.md),
> [ADR-016](ARCHITECTURE/ADR-016-quality-engineering-policy.md), and `tests/` directory.

### Configuration

- Load from environment variables. Use a `Config` struct with defaults.
- Naming convention: `CHAMICORE_<SERVICE>_<SETTING>` (e.g., `CHAMICORE_SMD_DB_DSN`).
- Common variables across services:
  - `CHAMICORE_<SERVICE>_LISTEN_ADDR` (default: `:PORT`)
  - `CHAMICORE_<SERVICE>_DB_DSN` (PostgreSQL connection string)
  - `CHAMICORE_<SERVICE>_LOG_LEVEL` (default: `info`)
  - `CHAMICORE_<SERVICE>_JWKS_URL` (chamicore-auth JWKS endpoint)
  - `CHAMICORE_INTERNAL_TOKEN` (shared secret for service-to-service auth)
  - `CHAMICORE_<SERVICE>_DEV_MODE` (disable auth for development)
  - `CHAMICORE_<SERVICE>_METRICS_ENABLED` / `TRACES_ENABLED` (default: `true`)
  - `CHAMICORE_<SERVICE>_PROMETHEUS_LISTEN_ADDR` (default: `:9090`)
- OTel SDK variables: `OTEL_SERVICE_NAME`, `OTEL_EXPORTER_OTLP_ENDPOINT`, etc.

---

## API Design Guidelines

> Full rationale: [ADR-007](ARCHITECTURE/ADR-007-api-design-conventions.md).

### REST Conventions

- Standard HTTP methods: GET (read), POST (create), PUT (full replace), PATCH (partial update), DELETE.
- Resource-oriented URLs: `/hsm/v2/State/Components/{id}`. Plural resource names.
- Version in URL path: `/hsm/v2/`, `/boot/v1/`.
- **PATCH semantics**: JSON Merge Patch (RFC 7396). Pointer fields: `nil` = don't change.

| Method | Success | Not Found | Validation Error | Conflict |
|--------|---------|-----------|------------------|----------|
| GET (one) | `200` | `404` | `400` | - |
| GET (list) | `200` | `200` (empty) | `400` | - |
| POST | `201` + `Location` | - | `400`/`422` | `409` |
| PUT | `200` | `404` | `400`/`422` | - |
| PATCH | `200` | `404` | `400`/`422` | - |
| DELETE | `204` | `404` | - | - |

### Filtering, Sorting, Pagination

- Filter via query params: `?type=Node&state=Ready`. Comma for OR: `?type=Node,Switch`.
- Sort: `?sort=created_at` (asc) or `?sort=-created_at` (desc). Default: `created_at DESC`.
- Unknown filter params are ignored (forward compatibility).
- Pagination: `?limit=100&offset=0`. Default limit: 100. Max limit: 10000.

### Bulk Operations

- Path: `<resource>/bulk`. Max 10,000 items (10 MB body limit).
- Not transactional — items succeed/fail independently. Returns `207 Multi-Status`.

### Structured Error Responses (RFC 9457)

All error responses follow [RFC 9457](https://www.rfc-editor.org/rfc/rfc9457):
```json
{"type":"about:blank","title":"Not Found","status":404,"detail":"Component X not found","instance":"/hsm/v2/State/Components/X"}
```
- Validation errors (422) include `"errors": [{"field":"ID","message":"..."}]` array.
- Unknown/extra JSON fields are rejected (`DisallowUnknownFields`).
- Helpers: `httputil.Problem(w, r, status, detail)`, `httputil.ValidationError(w, r, fieldErrors)`

### Resource Envelope Pattern

All responses use a Kubernetes-inspired envelope:

```go
// chamicore-lib/httputil
type Resource[T any] struct {
    Kind       string   `json:"kind"`       // e.g., "Component"
    APIVersion string   `json:"apiVersion"` // e.g., "hsm/v2"
    Metadata   Metadata `json:"metadata"`   // id, etag, createdAt, updatedAt
    Spec       T        `json:"spec"`
}
type ResourceList[T any] struct {
    Kind       string       `json:"kind"`       // e.g., "ComponentList"
    APIVersion string       `json:"apiVersion"`
    Metadata   ListMetadata `json:"metadata"`   // total, limit, offset
    Items      []Resource[T] `json:"items"`
}
```

### ETags (Conditional Requests)

- **Read path**: `ETag` header on GET → client sends `If-None-Match` → `304 Not Modified`.
- **Write path**: `If-Match` on PUT/PATCH → `412 Precondition Failed` if stale.
- ETags derived from `updatedAt` or content hash. Required on single-resource GETs and PUT/PATCH.

### Health Endpoints (no auth required)

| Endpoint | Purpose |
|----------|---------|
| `GET /health` | Liveness probe (`{"status":"ok"}`) |
| `GET /readiness` | Readiness probe (503 if not ready) |
| `GET /version` | Build version, commit, build time |
| `GET /metrics` | Prometheus scrape endpoint |
| `GET /api/docs` | Swagger UI |
| `GET /api/openapi.yaml` | OpenAPI spec |

Readiness prerequisites: DB connected+migrated, JWKS fetched, initial sync complete
(BSS/Cloud-Init/Kea-Sync).

### Request Body Limits

| Type | Limit |
|------|-------|
| Standard CRUD | 1 MB |
| Bulk endpoints | 10 MB |

### Middleware Stack (outermost first)

```go
r := chi.NewRouter()
r.Use(otelutil.HTTPTracing())         // 1. OTel tracing spans
r.Use(otelutil.HTTPMetrics())         // 2. OTel request metrics
r.Use(httputil.RequestID)             // 3. X-Request-ID injection
r.Use(httputil.RequestLogger)         // 4. Zerolog request logging
r.Use(middleware.Recoverer)           // 5. Panic recovery -> 500
r.Use(httputil.SecureHeaders)         // 6. X-Content-Type-Options, X-Frame-Options
r.Use(httputil.BodyLimit(1 << 20))    // 7. 1 MB default body limit
r.Use(httputil.ContentType)           // 8. Enforce application/json
r.Use(httputil.APIVersion("hsm/v2")) // 9. API-Version response header
r.Use(httputil.CacheControl)          // 10. Cache-Control headers
r.Use(httputil.ETag)                  // 11. If-None-Match / If-Match
r.Use(auth.JWTMiddleware(cfg))        // 12. JWT validation + claims
r.Use(auth.RequireScope("..."))       // 13. Per-route scope enforcement
```

### Type-Safe HTTP Clients

Each service provides a typed client in `pkg/client/` built on `chamicore-lib/httputil/client/`.
Features: typed structs (not raw JSON), automatic retries (429/502/503/504 with backoff),
RFC 9457 error parsing, context propagation, request ID forwarding, token injection.

---

## Observability

> Full details: [ADR-009](ARCHITECTURE/ADR-009-opentelemetry-observability.md).

All services export metrics and traces via OpenTelemetry. OTel SDK is initialized in
`main.go` via `otelutil.Init(ctx, otelutil.Config{...})`. Middleware handles HTTP
instrumentation automatically. Prometheus endpoint at `GET /metrics`.

---

## Database Conventions

### Shared PostgreSQL, Per-Service Schemas

- One PostgreSQL instance, single `chamicore` database.
- Per-service schemas: `smd`, `bss`, `cloudinit`, `auth`, `discovery`.
- Services never access another service's schema. Use HTTP APIs.
- Each service sets `search_path` to its own schema on connection.
- Pool sizing via `CHAMICORE_<SERVICE>_DB_MAX_OPEN_CONNS`, `_MAX_IDLE_CONNS`,
  `_CONN_MAX_LIFETIME`, `_CONN_MAX_IDLE_TIME`.

### Migrations

- Use [golang-migrate](https://github.com/golang-migrate/migrate) with PostgreSQL driver.
- Files: `migrations/postgres/000001_create_<table>.up.sql` / `.down.sql`.
- Run automatically on startup. Always provide both up and down. Never modify released migrations.

### Query Building

- Use [Masterminds/squirrel](https://github.com/Masterminds/squirrel) with `squirrel.Dollar` (PostgreSQL `$1`, `$2`).
- Use `lib/pq` as the PostgreSQL driver.
- Define `Store` interface in `internal/store/`, implement `PostgresStore`.

### Transactions

- Use `sql.Tx` only for multi-table writes. Begin in the **store method**, not the handler.
- Always `defer tx.Rollback()` immediately after `BeginTx`.
- Do NOT use transactions for single-table writes.

### Schema Conventions

- Table names: `snake_case`, plural (`components`, `boot_params`).
- Column names: `snake_case`. Primary keys: meaningful strings where appropriate.
- Timestamps: `created_at`, `updated_at` as `TIMESTAMPTZ`, default `NOW()`.
- Use `TEXT` over `VARCHAR` unless there's a specific length constraint.

### ID Generation

| Resource | Strategy |
|----------|----------|
| Components (SMD) | Client-provided (validated) or server-generated `<type>-<8hex>` |
| Most other resources | Server-generated UUID v4 (`gen_random_uuid()`) |
| Auth policies | Casbin-managed (composite key) |

Use `crypto/rand`, never `math/rand`.

---

## Security Patterns

### Authentication Flow

- **chamicore-auth** is the single auth service ([ADR-011](ARCHITECTURE/ADR-011-consolidated-auth-service.md)).
- Federates with external IdPs (Keycloak, Okta, Azure AD, GitHub) via OIDC.
- External tokens exchanged for short-lived, scoped Chamicore JWTs.
- Services validate JWTs via `chamicore-lib/auth` middleware + JWKS from chamicore-auth.
- Per-route scope enforcement: `auth.RequireScope()`.
- Casbin RBAC/ABAC policies managed via chamicore-auth API; scopes enforced locally.

### Service-to-Service Auth (Internal Token)

All internal microservice calls use a shared pre-shared token:
```
CHAMICORE_INTERNAL_TOKEN=<random-256-bit-hex-string>
```
- Sent as `Authorization: Bearer <internal-token>` on inter-service HTTP calls.
- `auth.JWTMiddleware` recognizes it before JWT validation, injects synthetic internal
  claims (`sub: "internal"`, all scopes, `internal: true`).
- **Never exposed to external clients.** External users/automation use JWTs.

| Caller | Auth Mechanism | Token Type |
|--------|---------------|------------|
| Human user (UI, CLI) | OIDC via chamicore-auth | JWT (short-lived, scoped) |
| External automation / CI | Service account in chamicore-auth | JWT (`sa: true` claim) |
| Internal microservice | `CHAMICORE_INTERNAL_TOKEN` | Pre-shared secret |

**Service accounts** are for **external consumers** (CI/CD, automation), not internal s2s calls.

### Development Mode

- `CHAMICORE_<SERVICE>_DEV_MODE=true` bypasses JWT and internal token checks.
- Injects synthetic admin claims. **Must never be enabled in production.**

---

## Key Library Choices

| Purpose | Library | Import Path |
|---------|---------|-------------|
| HTTP framework | go-chi/chi/v5 | `github.com/go-chi/chi/v5` |
| Logging | rs/zerolog | `github.com/rs/zerolog` |
| JWT | lestrrat-go/jwx/v2 | `github.com/lestrrat-go/jwx/v2` |
| PostgreSQL driver | lib/pq | `github.com/lib/pq` |
| Query builder | Masterminds/squirrel | `github.com/Masterminds/squirrel` |
| Migrations | golang-migrate/migrate/v4 | `github.com/golang-migrate/migrate/v4` |
| Authorization | casbin/casbin/v2 | `github.com/casbin/casbin/v2` |
| CLI framework | spf13/cobra | `github.com/spf13/cobra` |
| OTel SDK | opentelemetry-go | `go.opentelemetry.io/otel` |
| Test assertions | stretchr/testify | `github.com/stretchr/testify` |
| Test containers | testcontainers-go | `github.com/testcontainers/testcontainers-go` |
| Events (Phase 2) | nats-io/nats.go | `github.com/nats-io/nats.go` |

### Banned Dependencies

Do NOT introduce (legacy from upstream OpenCHAMI):
`Cray-HPE/hms-*`, `hashicorp/vault`, `etcd`, `Shopify/sarama` (Kafka),
`go-duckdb`, `go-sqlite3`, `gorilla/handlers`, `sirupsen/logrus`, `ory/hydra`, `OpenCHAMI/opaal`.

---

## CI/CD

### Git Conventions

- **Branch naming**: `<type>/<short-description>` (e.g., `feat/smd-component-crud`).
  Types: `feat`, `fix`, `refactor`, `test`, `docs`, `chore`.
- **Commit messages**: Imperative mood, max 72 chars first line. Reference task ID.
  One commit per completed task (squash if needed). Merge to `main` via MR.

### Per-Service Pipeline

1. Lint: `golangci-lint run`
2. Unit test: `go test -coverprofile=coverage.out -race ./...` (100% coverage enforced)
3. Integration test: `go test -tags integration -race ./...`
4. Build: `go build ./cmd/<service>/`
5. Docker: Build and push container image
6. Release: GoReleaser for tagged releases (`vMAJOR.MINOR.PATCH`)

> For release workflow, versioning strategy, and nightly performance pipelines, see
> the `.goreleaser.yml` template and [ADR-012](ARCHITECTURE/ADR-012-performance-testing-strategy.md).

---

## Progressive Development Approach

1. **No premature abstraction** — Concrete code first. Extract interfaces for 2+ implementations or testing seams.
2. **No premature optimization** — Profile before optimizing. Correct code first.
3. **No speculative features** — Implement what is needed now.
4. **Consistent patterns** — Follow established patterns across services.
5. **Document decisions** — Add ADRs in `ARCHITECTURE/` for significant decisions.

---

## Quick Reference

### Common Make Targets

```bash
make init              # Initialize submodules
make update            # Update all submodules
make build             # Build all services
make test              # Run unit tests
make test-cover        # Run unit tests with 100% coverage enforcement
make test-integration  # Run per-service integration tests (needs Docker)
make test-system       # Run cross-service system tests (starts full stack)
make test-smoke        # Run smoke tests against live stack
make test-load         # Run full load/performance tests (requires k6)
make lint              # Lint all services
make quality-gate      # Full local quality gate (lint/tests/coverage/integration)
make quality-db        # DB migration/schema/query-plan quality gate
make release-gate      # Release gate + signed quality report artifact
make docker-build      # Build all Docker images
make compose-up        # Start dev environment
make compose-down      # Stop dev environment
```

### Common Environment Variables

```bash
CHAMICORE_SMD_LISTEN_ADDR=:27779
CHAMICORE_SMD_DB_DSN=postgres://user:pass@localhost:5432/chamicore?sslmode=disable&search_path=smd
CHAMICORE_SMD_LOG_LEVEL=info
CHAMICORE_SMD_JWKS_URL=http://localhost:3333/.well-known/jwks.json
CHAMICORE_INTERNAL_TOKEN=<random-256-bit-hex-string>
CHAMICORE_SMD_DEV_MODE=false
OTEL_SERVICE_NAME=chamicore-smd
OTEL_EXPORTER_OTLP_ENDPOINT=http://localhost:4317
```

### Component Identifiers

Flat opaque string IDs ([ADR-010](ARCHITECTURE/ADR-010-component-identifiers.md)).
Format: `^[a-zA-Z0-9][a-zA-Z0-9._-]{0,253}[a-zA-Z0-9]$`

Types: `Cabinet`, `BMC`, `Node`, `Processor`, `Memory`, `Accelerator`, `NIC`, `Drive`, `PDU`, `Switch`.
Location: optional metadata `{"rack":"R12","unit":17,"slot":0}`.
Hierarchy: `parent_id` foreign key. Xnames accepted for compatibility.

---

## AI Agent Implementation Guide

### Before You Start: Context Loading

**Always read these files first** before implementing anything:
1. This file (`AGENTS.md`), 2. `IMPLEMENTATION.md`, 3. `templates/`, 4. Relevant ADR(s).

**Per-task context loading:**

| Working On | Also Read |
|-----------|-----------|
| chamicore-bss, cloud-init | [ADR-014](ARCHITECTURE/ADR-014-boot-path-data-flow.md) |
| chamicore-auth | [ADR-011](ARCHITECTURE/ADR-011-consolidated-auth-service.md) |
| chamicore-smd | [ADR-010](ARCHITECTURE/ADR-010-component-identifiers.md), upstream `OpenCHAMI/smd` |
| chamicore-discovery | [ADR-013](ARCHITECTURE/ADR-013-dedicated-discovery-service.md) |
| chamicore-kea-sync | Kea Control Agent API docs, [ADR-015](ARCHITECTURE/ADR-015-event-driven-architecture.md) |
| Any quality/testing/database drift work | [ADR-012](ARCHITECTURE/ADR-012-performance-testing-strategy.md), [ADR-016](ARCHITECTURE/ADR-016-quality-engineering-policy.md) |
| Any handler | `templates/service/internal/server/handlers.go` |
| Any store | `templates/service/internal/store/postgres.go` |
| Any client SDK | `templates/service/pkg/client/client.go` |

### Agent Workflow (mandatory)

```
1. READ context    → AGENTS.md + IMPLEMENTATION.md + relevant templates + ADRs
2. UNDERSTAND task → Read acceptance criteria in IMPLEMENTATION.md
3. CHECK deps      → Verify prerequisite tasks are complete
4. COPY template   → Start from templates/service/, not from scratch
5. IMPLEMENT       → Follow template patterns exactly
6. TEST            → Write tests FIRST where practical; achieve 100% coverage
7. LINT            → golangci-lint; fix all warnings
8. VERIFY          → Check against acceptance criteria
9. COMMIT          → Descriptive message referencing the task
```

**Critical rule**: Do NOT invent new patterns. Every pattern exists in `templates/service/`
or in a previously-implemented service.

### Code Generation Rules

#### Imports

```go
// CORRECT: Use chamicore-lib packages
import "git.cscs.ch/openchami/chamicore-lib/auth"
import "git.cscs.ch/openchami/chamicore-lib/httputil"
import "git.cscs.ch/openchami/chamicore-lib/dbutil"

// WRONG: Never import between services' internal packages
import "git.cscs.ch/openchami/chamicore-smd/internal/store"  // NEVER

// WRONG: Never use banned libraries (see Banned Dependencies above)
```

#### Function Signatures

```go
// Store: context first, return (result, error)
func (s *PostgresStore) GetComponent(ctx context.Context, id string) (*model.Component, error)

// Handler: standard http signature, no return values
func (s *Server) handleGetComponent(w http.ResponseWriter, r *http.Request)
```

#### Error Handling in Handlers

```go
component, err := s.store.GetComponent(ctx, id)
if errors.Is(err, store.ErrNotFound) {
    httputil.Problem(w, r, http.StatusNotFound, "Component %s not found", id)
    return
}
if err != nil {
    httputil.Problem(w, r, http.StatusInternalServerError, "Internal error")
    s.log.Error().Err(err).Str("id", id).Msg("failed to get component")
    return
}
```
- Wrap errors with context: `fmt.Errorf("querying component %s: %w", id, err)`
- Use sentinel errors: `errors.Is(err, sql.ErrNoRows) → ErrNotFound`
- Never panic in handlers or store. Never log deep in the store layer.

#### HTTP Responses

```go
// POST → 201 + Location header + envelope
resource := httputil.Resource[types.Spec]{Kind: "Component", APIVersion: "hsm/v2", ...}
w.Header().Set("Location", fmt.Sprintf("/hsm/v2/State/Components/%s", id))
httputil.JSON(w, http.StatusCreated, resource)
```
- Always use the envelope pattern. Never return raw specs.
- Correct status codes (see table above). POST=201, DELETE=204.

#### Database Queries

```go
// Always use squirrel with dollar placeholders + context
query, args, err := s.sb.Select("id", "type").From("components").Where(squirrel.Eq{"id": id}).ToSql()
err = s.db.QueryRowContext(ctx, query, args...).Scan(&c.ID, &c.Type)
```
- Never use string concatenation for SQL. Always use `*Context` variants.

### Anti-Patterns (DO NOT)

| Anti-Pattern | Correct Approach |
|-------------|-----------------|
| Creating `utils/` or `helpers/` package | Put in the using package, or `chamicore-lib` if shared |
| `context.TODO()` in production code | Always propagate context from caller |
| `interface{}` or `any` for typed data | Use concrete types or generics |
| Custom HTTP router | Use go-chi. Always. |
| `Base` or `Abstract` struct | Go uses composition, not inheritance |
| Global logger | Pass `zerolog.Logger` via struct field |
| `init()` functions | Initialize in `main()` |
| Returning `(int, error)` from handlers | Write to `http.ResponseWriter` directly |
| Blank line padding in functions | Keep tight; blank lines for logical sections only |
| Wrapper types for stdlib types | Use `*sql.DB`, `http.Client` directly |
| Comments restating code | Only comment non-obvious "why" decisions |
| `println`/`fmt.Printf` for debugging | Use `log.Debug()` from zerolog |
| `os.Exit()` outside `main()` | Return errors; caller decides |
| `_ = foo()` ignoring errors | Handle or document why safe to ignore |
| Tests depending on execution order | Each test independent. Use `t.Parallel()` |
| Cross-service HTTP on boot-serve path | BSS/Cloud-Init serve from local DB only ([ADR-014](ARCHITECTURE/ADR-014-boot-path-data-flow.md)) |
| JWT auth on boot endpoints | Boot endpoints are unauthenticated |

### Verification Checklist

#### Code Quality
- [ ] Code follows template patterns in `templates/service/`
- [ ] No banned dependencies, no `context.TODO()` outside `main()`/tests
- [ ] All exported types/functions have doc comments
- [ ] `golangci-lint run` passes with zero warnings

#### Testing
- [ ] `go test -race -coverprofile=coverage.out ./...` passes
- [ ] 100% coverage (or documented exclusions)
- [ ] All error paths and validation edge cases tested
- [ ] HTTP handlers tested via `httptest`
- [ ] Store has integration tests with `//go:build integration` tag
- [ ] No known flaky tests (shuffle/repeat strategy where relevant)
- [ ] Test expectations comply with ADR-016 quality gates

#### API Compliance
- [ ] Endpoints match `api/openapi.yaml` (methods, paths, status codes, response shapes)
- [ ] Responses use envelope pattern, errors follow RFC 9457
- [ ] `ETag` on single-resource GETs, `Location` on POST 201
- [ ] Pagination with `limit`/`offset`, unknown fields rejected

#### Database
- [ ] Migrations: both `.up.sql` and `.down.sql`, correct schema name
- [ ] Tables have `created_at`/`updated_at` TIMESTAMPTZ, `search_path` set
- [ ] Squirrel queries with dollar placeholders, `*Context` methods
- [ ] Migration and schema checks align with ADR-016 drift controls

#### Security
- [ ] JWT middleware on all API routes, scope enforcement on mutations
- [ ] Dev mode only when `DEV_MODE=true`, no secrets in logs/responses
- [ ] SQL injection impossible (parameterized queries)

### Naming Conventions

| What | Convention | Example |
|------|-----------|---------|
| Module path | `git.cscs.ch/openchami/chamicore-<service>` | `chamicore-smd` |
| Schema name | Short lowercase | `smd`, `bss`, `cloudinit`, `auth`, `discovery` |
| Env var prefix | `CHAMICORE_<SERVICE>_` | `CHAMICORE_SMD_DB_DSN` |
| API prefix | Service-specific | `/hsm/v2/`, `/boot/v1/`, `/auth/v1/` |
| Resource kind | PascalCase singular/+`List` | `Component`, `ComponentList` |
| Table name | snake_case plural | `components`, `boot_params` |
| Handler function | `handle<Verb><Resource>` | `handleGetComponent` |
| Store/Client method | `<Verb><Resource>` | `GetComponent`, `ListBootParams` |
| Test function | `Test<Unit>_<Scenario>` | `TestGetComponent_NotFound` |
| Error sentinel | `Err<Condition>` | `ErrNotFound`, `ErrConflict` |
